#%%
import pandas as pd
import numpy as np
import os
import matplotlib.pyplot as plt
import random
import pickle as pkl
from ObjectGenerator import ObjectGenerator
from ParameterRandomizer import ParameterRandomizer
#%%
class DatasetGenerator():
    def __init__(self,save_path):
        self.save_path = save_path
        self.obj_gen = ObjectGenerator()
        self.ParameterRandomizer = ParameterRandomizer()

    def add_to_dict(self,dict_of_parameters,dict_to_add):
        for key in dict_to_add:
            dict_of_parameters[key] = dict_to_add[key]
        return dict_of_parameters

    def save_dataset(self,dataset, name):
        pkldir = os.path.join(self.save_path, "pkl")
        os.makedirs(pkldir, exist_ok=True)
        pklpath = os.path.join(pkldir, name)

        with open(pklpath, "wb") as file:
            pkl.dump(dataset, file)
        print("Dataset saved to", pklpath)

    def write_cif(self, dataframe,drprobe_frame, filename):
        """
        Writes a CIF file from a pandas DataFrame with columns x, y, z, and label (element),
        calculating the cell lengths from the smallest bounding box that encompasses all atoms.

        :param dataframe: Pandas DataFrame containing the columns x, y, z, label (element).
        :param filename: Name of the CIF file to be created.
        """
        #drprobe_frame, minx,maxx,miny,maxy,minz,maxz
        # Calculate bounding box dimensions
        range_x = drprobe_frame[1] - drprobe_frame[0]
        range_y = drprobe_frame[3] - drprobe_frame[2]
        range_z = drprobe_frame[5] - drprobe_frame[4]
        max_range = max(range_x, range_y, range_z)

        # Cell lengths are uniform for the bounding cube
        cell_length = max_range


        # Ensure 'cifs' directory exists
        os.makedirs('cifs', exist_ok=True)
        file_path = os.path.join('cifs', filename)

        # Write CIF file
        with open(file_path, 'w') as file:
            # Header and cell parameters
            file.write("data_global\n")
            file.write("_audit_creation_method 'Generated by Python Script'\n")
            file.write("\n")
            file.write("_symmetry_space_group_name_H-M 'P 1'\n")
            file.write("_symmetry_Int_Tables_number 1\n")
            file.write("_symmetry_cell_setting triclinic\n")
            file.write("loop_\n")
            file.write("_symmetry_equiv_pos_as_xyz\n")
            file.write("  'x, y, z'\n")
            file.write("\n")
            file.write(f"_cell_length_a    {cell_length*10}\n")
            file.write(f"_cell_length_b    {cell_length*10}\n")
            file.write(f"_cell_length_c    {cell_length*10}\n")
            file.write("_cell_angle_alpha 90.0\n")
            file.write("_cell_angle_beta  90.0\n")
            file.write("_cell_angle_gamma 90.0\n")
            file.write("\n")
            file.write("loop_\n")
            file.write("_atom_site_label\n")
            file.write("_atom_site_occupancy\n")
            file.write("_atom_site_fract_x\n")
            file.write("_atom_site_fract_y\n")
            file.write("_atom_site_fract_z\n")
            file.write("_atom_site_adp_type\n")
            file.write("_atom_site_U_iso_or_equiv\n")
            file.write("_atom_site_type_symbol\n")

            min_x, min_y, min_z = drprobe_frame[0], drprobe_frame[2], drprobe_frame[4]
            for index, row in dataframe.iterrows():
                fract_x = (row['x'] - min_x) / cell_length
                fract_y = (row['y'] - min_y) / cell_length
                fract_z = (row['z'] - min_z) / cell_length
                file.write(f"{row['label']}1  1.0  {fract_x}  {fract_y}  {fract_z}  Uiso  ?  {row['label']}\n")
    
    def rotate_to_drprobe_view(self, dataframe):
        """
        Rotates z axis to x axis
        """
        # Rotate to DRProbe view
        # Rotate by 90 degrees about x axis
        rotation_matrix = np.array([[1, 0, 0], [0, 0, -1], [0, 1, 0]])
        dataframe[['x', 'y', 'z']] = dataframe[['x', 'y', 'z']].dot(rotation_matrix)
        return dataframe

    def crop_structure(self, dataframe, pixel_size=None):
        #find the bounding box of the particle coordinates in the xy plane
        particle = dataframe[dataframe["label"] == "Pt"]
        buffer = 0.1 #nm
        min_x = particle["x"].min() - buffer
        max_x = particle["x"].max() + buffer
        min_y = particle["y"].min() - buffer
        max_y = particle["y"].max() + buffer


        image_size = 128
        min_pixel_size = max((max_x-min_x)/image_size,(max_y-min_y)/image_size)
        print("min pixel size",min_pixel_size)
        if pixel_size is None:
            if min_pixel_size+0.002 < 0.015:
                pixel_size = random.uniform(min_pixel_size,0.035)
            else:
                pixel_size = random.uniform(max(min_pixel_size+0.002,0.015),max(min_pixel_size+0.003,0.035))
        print(pixel_size)


        new_box_size = pixel_size * 128
        # center the box on the particle
        center_x = (min_x + max_x)/2
        center_y = (min_y + max_y)/2
        min_x_new = center_x - new_box_size/2
        max_x_new = center_x + new_box_size/2
        min_y_new = center_y - new_box_size/2
        max_y_new = center_y + new_box_size/2

        max_offset_x = max_x_new - max_x
        max_offset_y = max_y_new - max_y
        #random x and y offset from 0 to (max_x-min_x)/2 and 0 to (max_y-min_y)/2
        x_offset = random.uniform(0,min(max_offset_x,(max_x-min_x)/2))*random.choice([-1,1])
        y_offset = random.uniform(0,min(max_offset_y,(max_y-min_y)/2))*random.choice([-1,1])
        min_x_new = min_x_new + x_offset
        max_x_new = max_x_new + x_offset
        min_y_new = min_y_new + y_offset
        max_y_new = max_y_new + y_offset

        center_of_box_x = (min_x_new + max_x_new)/2
        center_of_box_y = (min_y_new + max_y_new)/2
        #plot the Pt atoms and the bounding box in the xy plane and the 128x128 pixel box

        crop_box_min_x = min_x_new-0.5
        crop_box_max_x = max_x_new+0.5
        crop_box_min_y = min_y_new-0.5
        crop_box_max_y = max_y_new+0.5
        cropped_df = dataframe[(dataframe["x"] > crop_box_min_x) & (dataframe["x"] < crop_box_max_x) & (dataframe["y"] > crop_box_min_y) & (dataframe["y"] < crop_box_max_y)]
        in_image_df = dataframe[(dataframe["x"] > min_x_new) & (dataframe["x"] < max_x_new) & (dataframe["y"] > min_y_new) & (dataframe["y"] < max_y_new)]
        drprobe_frame_min_x = crop_box_min_x - 1
        drprobe_frame_max_x = crop_box_max_x + 1
        drprobe_frame_min_y = crop_box_min_y - 1
        drprobe_frame_max_y = crop_box_max_y + 1

        print("max_z",cropped_df["z"].max())
        print("min_z",cropped_df["z"].min())
        if abs(cropped_df["z"].max()) < (drprobe_frame_max_x-drprobe_frame_min_x)/2 and abs(cropped_df["z"].min()) < (drprobe_frame_max_x-drprobe_frame_min_x)/2:
            drprobe_frame_max_z = (drprobe_frame_max_x-drprobe_frame_min_x)/2
            drprobe_frame_min_z = -drprobe_frame_max_z
        else:
            max_abs_z = max(abs(cropped_df["z"].max()),abs(cropped_df["z"].min()))
            drprobe_frame_max_z = 1+max_abs_z
            drprobe_frame_min_z = -drprobe_frame_max_z
            range_z = drprobe_frame_max_z - drprobe_frame_min_z
            range_x = drprobe_frame_max_x - drprobe_frame_min_x
            diff = range_z - range_x
            drprobe_frame_max_x += diff/2
            drprobe_frame_min_x -= diff/2
            drprobe_frame_max_y += diff/2
            drprobe_frame_min_y -= diff/2
        range_z = drprobe_frame_max_z - drprobe_frame_min_z
        range_x = drprobe_frame_max_x - drprobe_frame_min_x
        range_y = drprobe_frame_max_y - drprobe_frame_min_y
        print(range_x,range_y,range_z)
        #assert np all close(range_x,range_y,range_z), "The drprobe frame is not cubic"
        assert np.allclose(range_x,range_y,range_z), "The drprobe frame is not cubic"

        drprobe_frame= [drprobe_frame_min_x,drprobe_frame_max_x,drprobe_frame_min_y,drprobe_frame_max_y,drprobe_frame_min_z,drprobe_frame_max_z]

        plt.figure()
        plt.plot(center_of_box_x,center_of_box_y,"rx")
        plt.scatter(cropped_df["x"],cropped_df["y"],c=cropped_df["label"].replace({"Ce":"b","O":"r","Pt":"g"}))
        plt.plot([min_x,max_x,max_x,min_x,min_x],[min_y,min_y,max_y,max_y,min_y])
        plt.plot([min_x_new,max_x_new,max_x_new,min_x_new,min_x_new],[min_y_new,min_y_new,max_y_new,max_y_new,min_y_new])
        plt.plot([crop_box_min_x,crop_box_max_x,crop_box_max_x,crop_box_min_x,crop_box_min_x],[crop_box_min_y,crop_box_min_y,crop_box_max_y,crop_box_max_y,crop_box_min_y])
        plt.plot([drprobe_frame_min_x,drprobe_frame_max_x,drprobe_frame_max_x,drprobe_frame_min_x,drprobe_frame_min_x],[drprobe_frame_min_y,drprobe_frame_min_y,drprobe_frame_max_y,drprobe_frame_max_y,drprobe_frame_min_y])
        plt.axis("equal")
        plt.show()
        
        beam_offset = [min_y_new-drprobe_frame_min_y,min_x_new-drprobe_frame_min_x]
        beam_offset = [round(value, 2) for value in beam_offset]
        print("beam offset",beam_offset)
        return pixel_size, cropped_df,in_image_df, drprobe_frame, beam_offset

    def complete_structure(self,structure_df,cropped_dataframe,pixel_size,beam_offset,sample_id,subset, in_image_df, dict_of_parameters):
        structure_df['support_interface'] = dict_of_parameters['surface_facet']
        structure_df['particle_interface'] = dict_of_parameters['particle_surface_facet']
        #add column "in crop" to structure_df and set to 1 if the atom is in the cropped dataframe
        structure_df['in_crop'] = structure_df.merge(cropped_dataframe, on=['x', 'y', 'z'], how='left', indicator=True)['_merge'].eq('both').astype(int)
        structure_df['in_image'] = structure_df.merge(in_image_df, on=['x', 'y', 'z'], how='left', indicator=True)['_merge'].eq('both').astype(int)
        # Add column "pixel_size" to structure_df and set to pixel_size
        structure_df['pixel_size'] = pixel_size
        # Add column "beam_offset" to structure_df and set to beam_offset
        # Assuming beam_offset is a tuple (beam_offset_x, beam_offset_y), we need to separate these values into two columns
        structure_df['beam_offset_x'] = beam_offset[0]
        structure_df['beam_offset_y'] = beam_offset[1]

        structure_df['particle_rotation'] = dict_of_parameters['particle_rotation']
        # Add column "sample_id" to structure_df and set to sample_id
        structure_df['sample_id'] = sample_id

        # Add column "subset" to structure_df and set to subset
        structure_df['subset'] = subset

        return structure_df

    def generate_dataset(self,num_structures, composition, support_layers=8, support_depth=50, support_width=50, CeO2_bulk_depth=20, CeO2_bulk_width=20, CeO2_bulk_height=20, Pt_bulk_depth=10, Pt_bulk_width=10, Pt_bulk_height=10, wulff_element="Pt", wulff_rounding="above", cluster_element="Pt"):
        """
        num_structures: The number of structures to generate
        Composition = [num_random,num_wulff,num_cluster] """
        assert sum(composition) == num_structures, "The sum of the composition must equal the number of structures"
        dfs = []
        j = 0
        for i in range(composition[0]): # Random structure
            dict_of_parameters = self.ParameterRandomizer.randomize_parameters("random")
            dict_of_parameters = self.add_to_dict(dict_of_parameters,{"support_layers":support_layers,
                                                                        "support_depth":support_depth,
                                                                        "support_width":support_width,
                                                                        "CeO2_bulk_depth":CeO2_bulk_depth,
                                                                        "CeO2_bulk_width":CeO2_bulk_width,
                                                                        "CeO2_bulk_height":CeO2_bulk_height,
                                                                        "Pt_bulk_depth":Pt_bulk_depth,
                                                                        "Pt_bulk_width":Pt_bulk_width,
                                                                        "Pt_bulk_height":Pt_bulk_height})
            structure_df = self.obj_gen.generate_atomic_structure("random",dict_of_parameters)
            structure_df["structure_type"] = "random"
            structure_df[["x","y","z"]] = structure_df[["x","y","z"]]*0.1
            structure_df = self.rotate_to_drprobe_view(structure_df)
            pixel_size, cropped_dataframe,in_image_df, drprobe_frame, beam_offset = self.crop_structure(structure_df)
            self.write_cif(cropped_dataframe,drprobe_frame,f"{j}.cif")
            sample_id = j
            subset = "None"
            structure_df = self.complete_structure(structure_df,cropped_dataframe,pixel_size,beam_offset,sample_id,subset,in_image_df, dict_of_parameters)
            dfs.append(structure_df)
            self.save_dataset(structure_df,f"structure_{j}.pkl")
            j += 1
            print(j)
            #self.obj_gen.mayavi_atomic_structure(visu)

        for i in range(composition[1]):
            dict_of_parameters = self.ParameterRandomizer.randomize_parameters("wulff")
            #print("wulff size",dict_of_parameters["wulff_size"])
            dict_of_parameters = self.add_to_dict(dict_of_parameters,{"support_layers":support_layers,
                                                                        "support_depth":support_depth,
                                                                        "support_width":support_width,
                                                                        "CeO2_bulk_depth":CeO2_bulk_depth,
                                                                        "CeO2_bulk_width":CeO2_bulk_width,
                                                                        "CeO2_bulk_height":CeO2_bulk_height,
                                                                        "wulff_element":wulff_element,
                                                                        "wulff_rounding":wulff_rounding})
            structure_df = self.obj_gen.generate_atomic_structure("wulff",dict_of_parameters)
            structure_df["structure_type"] = "wulff"
            #make nm from A
            structure_df[["x","y","z"]] = structure_df[["x","y","z"]]*0.1
            structure_df = self.rotate_to_drprobe_view(structure_df)
            pixel_size, cropped_dataframe,in_image_df, drprobe_frame, beam_offset = self.crop_structure(structure_df)
            self.write_cif(cropped_dataframe,drprobe_frame,f"{j}.cif")
            sample_id = j
            subset = "None"
            structure_df = self.complete_structure(structure_df,cropped_dataframe,pixel_size,beam_offset,sample_id,subset,in_image_df, dict_of_parameters)
            dfs.append(structure_df)
            self.save_dataset(structure_df,f"structure_{j}.pkl")
            j += 1
            print(j)
            #visu = cropped_dataframe.copy()
            #visu[["x","y","z"]] = visu[["x","y","z"]] * 10
            #visu.label = visu.label.replace({'Ce': 0, 'O': 1, 'Pt': 2})
            #self.obj_gen.mayavi_atomic_structure(visu)
            
        for i in range(composition[2]):
            dict_of_parameters = self.ParameterRandomizer.randomize_parameters("cluster")
            dict_of_parameters = self.add_to_dict(dict_of_parameters,{"support_layers":support_layers,
                                                                        "support_depth":support_depth,
                                                                        "support_width":support_width,
                                                                        "CeO2_bulk_depth":CeO2_bulk_depth,
                                                                        "particle_surface_facet":"111",
                                                                        "CeO2_bulk_width":CeO2_bulk_width,
                                                                        "CeO2_bulk_height":CeO2_bulk_height,
                                                                        "cluster_element":cluster_element})
            structure_df = self.obj_gen.generate_atomic_structure("cluster",dict_of_parameters)
            structure_df["structure_type"] = "cluster"
            structure_df[["x","y","z"]] = structure_df[["x","y","z"]]*0.1
            structure_df = self.rotate_to_drprobe_view(structure_df)
            pixel_size, cropped_dataframe,in_image_df, drprobe_frame, beam_offset = self.crop_structure(structure_df)
            self.write_cif(cropped_dataframe,drprobe_frame,f"{j}.cif")
            sample_id = j
            subset = "None"
            structure_df = self.complete_structure(structure_df,cropped_dataframe,pixel_size,beam_offset,sample_id,subset,in_image_df, dict_of_parameters)
            dfs.append(structure_df)
            self.save_dataset(structure_df,f"structure_{j}.pkl")
            j += 1
            print(j)
            #elf.obj_gen.mayavi_atomic_structure(visu)

        dataset = pd.concat(dfs,ignore_index=True)
        self.save_dataset(dataset,"dataset.pkl")
#%%
data_gen = DatasetGenerator(os.getcwd())
data_gen.generate_dataset(10,[4,3,3])
#%%

dataset = pd.read_pickle("pkl/dataset.pkl")
print(dataset.columns)
print(np.unique(dataset["structure_type"]))
#%%
print(dataset)
# %%
